module Rubanok
  # Transformation parameters
  type params = Hash[Symbol | String, untyped]
  type field = Symbol
  # Transformation target (we assume that input and output types are the same)
  type input = Object?

  class Processor
    include DSL::Matching
    extend DSL::Matching::ClassMethods

    include DSL::Mapping
    extend DSL::Mapping::ClassMethods

    self.@rules: Array[Rule]

    def self.superclass: () -> singleton(Processor)

    def self.call: (params) -> input
                 | (input, params) -> input
    def self.add_rule: (Rule rule) -> void
    def self.rules: () -> Array[Rule]
    def self.fields_set: () -> Set[field]
    def self.project: (params) -> params
    def self.prepare: () { () -> input } -> void

    def initialize: (input) -> void
    def call: (params) -> input

    attr_accessor input: input

    private
    attr_accessor prepared: bool

    alias raw input
    alias prepared? prepared

    def apply_rule!: (Rule rule, params) -> void
    def prepare: () -> input
    def prepare!: () -> void
    def rules: () -> Array[Rule]
  end

  Plane: singleton(Processor)
end
